# Стратегия

## Задача

1. Реализовать возможность "эволюции" планет различными способами: потеря атмосферы (`LoseAtmosphere`), появление вулканов (`GainVolcanoes`), замерзание или кипение (`FreezeOrBoil`).  
   Перечень способов может быть расширен в будущем.  
   **Изменять класс Planet и его интерфейс нельзя**, так как он используется во всех подклассах и контейнерах.

2. Обеспечить единообразный вызов метода `evolve()` для всех планет, независимо от конкретной стратегии.

## Решение с использованием паттерна "Стратегия"

1. Создан абстрактный класс `EvolutionStrategy` с виртуальной функцией `Evolve(Planet*)`.
2. Реализованы стратегии:
   - `LoseAtmosphere`
   - `GainVolcanoes`
   - `FreezeOrBoil`
3. В классе `Planet` добавлено поле `strategy` (указатель на `EvolutionStrategy`).
4. Добавлен метод `SetEvolutionStrategy(EvolutionStrategy*)`, который назначает стратегию.
5. Метод `evolve()` вызывает стратегию через `strategy->Evolve(this)`.

## Краткая характеристика паттерна "Стратегия"

**Паттерн "Стратегия"** позволяет вынести алгоритмы поведения в отдельные классы, делая их взаимозаменяемыми. Это облегчает добавление новых алгоритмов и уменьшает зависимость между клиентом и реализацией.

---

# Шаблонный метод

## Задача

1. Унифицировать структуру алгоритма "столкновения" планет.
2. Разделить общую логику (ввод, проверка, выполнение, отказ) от частной логики условия и действия.

## Решение с использованием паттерна "Шаблонный метод"

1. Создан абстрактный базовый класс `CollisionTemplate` с методом `Collide(Planet*, Planet*)`, реализующим общий алгоритм:
   - Вывод начала
   - Проверка условия через `IsCollisionAllowed(...)`
   - Выполнение столкновения через `PerformCollision(...)`
   - Сообщение при отказе

2. Абстрактные методы `IsCollisionAllowed` и `PerformCollision` переопределяются в подклассах:
   - `EvenMoonsCollision` — столкновение разрешено, если у обеих планет четное число лун.
   - `OddMoonsCollision` — если хотя бы у одной планеты нечетное число лун.

## Краткая характеристика паттерна "Шаблонный метод"

**Паттерн "Шаблонный метод"** задаёт каркас алгоритма в базовом классе и позволяет подклассам переопределить отдельные шаги, не изменяя структуру самого алгоритма.

---

# Итератор и адаптер

## Задача

1. Организовать универсальный обход объектов планет из различных контейнеров.
2. Использовать паттерн "Итератор" для независимого обхода как массива, так и `std::vector`.

## Реализация

1. Абстрактный шаблон `Iterator<T>` определяет интерфейс обхода.
2. Реализованы два конкретных итератора:
   - `PlanetIterator` — для массива (PlanetContainer)
   - `VectorPlanetIterator` — для `std::vector` (VectorPlanetContainer)
3. `ConstIteratorAdapter` адаптирует любой STL-контейнер к `Iterator<T>`.

## Декораторы

1. `EvenMoonsDecorator` — пропускает планеты с нечетным числом лун.
2. `OddMoonsDecorator` — пропускает планеты с четным числом лун.
3. `OnlyGasGiantDecorator` — пропускает все, кроме `GasGiant`.

---
